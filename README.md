# GlidedSky爬虫闯关题
网址：[镀金的天空](http://www.glidedsky.com)

以下为本人学习记录，每个题目的学习点应该时因人而异的
## 第一关--基础1
#### 描述
从一网页获取内容

* 访问该网站需要登录，即需要cookie，最简单的方法就是复制浏览器里的cookie。
* 但是后面的题目都是需要cookie的，我估计这个cookie是有时效的，免得每次都要去复制，写了一个获取cookie并保存到本地的函数，一次获取一直使用，直到失效了，再次获取。
#### 收获
* 构造了两个函数，并独立成模块
    * 保存cookie（含登录信息）到本地的函数
    * 加载cookie到内存的函数
* 第一次采用requests.Session，并操作cookie
    * 使用会话，可以重用进程的TCP连接，**可能能解决后期下载速度慢的问题**
    * 使用会话，会保留下一次请求的中cookie（如果响应头里有set-cookie）保存为session级的参数，但是方法级的参数优先级高于session级，故在请求方法中写了cookies参数，将覆盖session的cookie

## 第二关--基础2
#### 描述
获取1000个页面的内容
* 多页面首先想到找url的规律，然后循环请求；但是1000个页面实在有点多，要是只有一个进程请求的话，得要一段时间，故采用多进程并行请求
* 按之前的经验，多进程请求（multiprocessing.Pool），一些页面会因为一些原因没有请求成功而被遗漏

#### 收获
* 使用yield来构造生成器
* 解决请求被遗漏的问题
    * Pool进程池运行过程：首先加载n个（自己定的）进程，然后当一个进程的任务完成或任务出现异常，都会加载池子里的下一个进程。
    * **任务异常不会使得该进程变成僵尸进程**，请求被遗漏就是出现异常导致的
    * 因此通过队列，提取任务异常的任务，返回给主进程，再次加入进程池就好了
* 使用了multiprocessing.Manager来管理进程间的通信
    * 实例一个Manager, 使用其Queue、Value、Lock
    * 通过Value来计数，用于进度条
    * 通过Queue来传递内容
    * Value对象自加操作，必须加锁，不然同一时间发生的会覆盖掉
